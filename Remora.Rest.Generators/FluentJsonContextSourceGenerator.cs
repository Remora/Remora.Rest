//
//  SPDX-FileName: FluentJsonContextSourceGenerator.cs
//  SPDX-FileCopyrightText: Copyright (c) Jarl Gullberg
//  SPDX-License-Identifier: LGPL-3.0-or-later
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace Remora.Rest.Generators;

/// <summary>
/// Generates System.Text.Json-based type info contexts for use in AOT scenarios.
/// </summary>
[Generator]
public class FluentJsonContextSourceGenerator : ISourceGenerator
{
    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ContextAssociationCallSyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        var syntaxReceiver = (ContextAssociationCallSyntaxReceiver)context.SyntaxReceiver!;
        foreach (var contextName in syntaxReceiver.ContextNames)
        {
            var semanticModel = context.Compilation.GetSemanticModel(contextName.SyntaxTree);
            var contextType = semanticModel.GetTypeInfo(contextName);

            INamedTypeSymbol contextTypeSymbol;
            switch (contextType.Type)
            {
                case IErrorTypeSymbol:
                {
                    // not something that exists yet, probably
                    continue;
                }
                case INamedTypeSymbol nts:
                {
                    contextTypeSymbol = nts;
                    break;
                }
                case null:
                {
                    throw new InvalidOperationException
                    (
                        "The context type name is not an expression that refers to a usable type"
                    );
                }
                default:
                {
                    // probably raise a diagnostic?
                    continue;
                }
            }

            if (contextTypeSymbol.BaseType?.Name != "JsonSerializerContext")
            {
                // diagnostic or error out?
                continue;
            }

            var converterInitializations = CreateConverterInitializations(context, contextTypeSymbol);

            if (converterInitializations.Count <= 0)
            {
                // no optionals in use here
                continue;
            }

            var contextNamespace = GetContextDeclarationNamespace(context, contextTypeSymbol);

            var source = SourceText.From
            (
                $$"""
                  // <auto-generated/>
                  #pragma warning disable CS0618

                  using System.Text.Json;
                  using Remora.Rest.Json.Configuration;
                  using Remora.Rest.Json.Converters;
                  {{contextNamespace}}
                  public partial class {{contextType.Type.Name}} : IAdditionalConverterProvider
                  {
                      public IReadOnlyList<JsonConverter> IAdditionalConverterProvider.AdditionalConverters { get; } = new JsonConverter[]
                      {
                          {{string.Join(",\n        ", converterInitializations)}}
                      };
                  }
                  """,
                encoding: Encoding.UTF8
            );

            var hintName = $"{contextType.Type.Name}.AdditionalConverters.g.cs";
            context.AddSource(hintName, source);
        }
    }

    private static string GetContextDeclarationNamespace
    (
        GeneratorExecutionContext context,
        INamedTypeSymbol typeSymbol
    )
    {
        var contextNamespace = typeSymbol.ContainingNamespace ?? context.Compilation.GlobalNamespace;
        var contextNamespaceString = contextNamespace.IsGlobalNamespace
            ? string.Empty
            : $"\nnamespace {contextNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty)};\n";

        return contextNamespaceString;
    }

    private static IReadOnlyList<string> CreateConverterInitializations
    (
        GeneratorExecutionContext context,
        INamedTypeSymbol typeSymbol
    )
    {
        var converterInitializations = new List<string>();

        var roots = typeSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.Name == "JsonSerializableAttribute")
            .Select(a => (ITypeSymbol)a.ConstructorArguments[0].Value!)
            .Where(x => x is not null)
            .ToArray();

        HashSet<ITypeSymbol> referencedTypes = new(SymbolEqualityComparer.Default);
        foreach (var root in roots)
        {
            ExpandReferencedTypes(root, referencedTypes);
        }

        List<INamedTypeSymbol> optionalTypes = new();
        INamedTypeSymbol? optionalBaseSymbol = null;
        foreach (var referencedType in referencedTypes.OfType<INamedTypeSymbol>())
        {
            // some simple heuristics first
            if (!referencedType.IsValueType)
            {
                continue;
            }

            if (!referencedType.IsGenericType)
            {
                continue;
            }

            if (referencedType.Name is not "Optional")
            {
                continue;
            }

            // likely to be an optional
            if (optionalBaseSymbol is null)
            {
                // also probably the first one we see, so try to look up the right base type
                var declaringSyntax = referencedType.DeclaringSyntaxReferences[0];
                var typeSemanticContext = context.Compilation.GetSemanticModel(declaringSyntax.SyntaxTree);
                var namespacesAndTypes = typeSemanticContext.LookupNamespacesAndTypes(declaringSyntax.Span.Start);
                var optionalBase = namespacesAndTypes
                    .Where
                    (
                        s => s is INamedTypeSymbol
                        {
                            ContainingNamespace:
                            { Name: "Core", ContainingNamespace: { Name: "Rest", ContainingNamespace.Name: "Remora" } }
                        }
                    )
                    .Cast<INamedTypeSymbol>()
                    .SingleOrDefault(s => s.Name is "Optional");

                if (optionalBase is null)
                {
                    // someone else using the same name and general structure, but our optional is not referenced
                    continue;
                }

                optionalBaseSymbol = optionalBase;
            }

            if (!referencedType.ConstructedFrom.Equals(optionalBaseSymbol, SymbolEqualityComparer.Default))
            {
                // definitely not our optional
                continue;
            }

            optionalTypes.Add(referencedType);
        }

        converterInitializations.AddRange
        (
            optionalTypes.Select
                (o => $"new OptionalConverter<{GetFullyQualifiedSymbolName(o.TypeArguments.Single(), context)}>()")
        );

        return converterInitializations;
    }

    private static void ExpandReferencedTypes(ITypeSymbol symbol, HashSet<ITypeSymbol> foundTypes)
    {
        // If it has already been seen, no need to check it again.
        if (!foundTypes.Add(symbol))
        {
            return;
        }

        if (symbol.BaseType is { } @base)
        {
            ExpandReferencedTypes(@base, foundTypes);
        }

        foreach (var implementedInterface in symbol.Interfaces)
        {
            ExpandReferencedTypes(implementedInterface, foundTypes);
        }

        foreach (var member in symbol.GetMembers())
        {
            // We only care about public properties for now
            if (member.DeclaredAccessibility == Accessibility.Public &&
                member is IPropertySymbol property)
            {
                ExpandReferencedTypes(property.Type, foundTypes);
            }
        }
    }

    private static string GetFullyQualifiedSymbolName(ITypeSymbol type, GeneratorExecutionContext context)
    {
        var keywordName = type.SpecialType switch
        {
            SpecialType.System_Boolean => "bool",
            SpecialType.System_Byte => "byte",
            SpecialType.System_Char => "char",
            SpecialType.System_Decimal => "decimal",
            SpecialType.System_Double => "double",
            SpecialType.System_Int16 => "short",
            SpecialType.System_Int32 => "int",
            SpecialType.System_Int64 => "long",
            SpecialType.System_Object => "object",
            SpecialType.System_SByte => "sbyte",
            SpecialType.System_String => "string",
            SpecialType.System_UInt16 => "ushort",
            SpecialType.System_UInt32 => "uint",
            SpecialType.System_UInt64 => "ulong",
            _ => null
        };

        if (keywordName is not null)
        {
            return keywordName;
        }

        var typeNamespace = type.ContainingNamespace
                            ?? context.Compilation.GlobalNamespace;

        var namespaceString = typeNamespace.IsGlobalNamespace
            ? "global::"
            : $"{typeNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.";

        return $"{namespaceString}{type.Name}";
    }
}
