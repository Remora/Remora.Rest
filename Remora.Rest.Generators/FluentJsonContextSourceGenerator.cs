//
//  SPDX-FileName: FluentJsonContextSourceGenerator.cs
//  SPDX-FileCopyrightText: Copyright (c) Jarl Gullberg
//  SPDX-License-Identifier: LGPL-3.0-or-later
//

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Remora.Rest.Generators;

/// <summary>
/// Generates System.Text.Json-based type info contexts for use in AOT scenarios.
/// </summary>
[Generator(LanguageNames.CSharp)]
public class FluentJsonContextSourceGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // filter out all targets for generation
        // at no point should a symbol, syntax or compilation be part of the incremental pipeline
        var targets = context.SyntaxProvider.CreateSyntaxProvider
        (
            predicate: static (node, _) => IsSyntaxNodeCandidate(node),
            transform: static (context, _) => TransformSyntaxNode(context)
        )
        .Where(static model => model != default);

        context.RegisterSourceOutput(targets, Execute);
    }

    private static bool IsSyntaxNodeCandidate(SyntaxNode node)
    {
        if (node is not InvocationExpressionSyntax invocation)
        {
            return false;
        }

        if (invocation.Expression is not MemberAccessExpressionSyntax access)
        {
            return false;
        }

        if (access.Name is not GenericNameSyntax generic)
        {
            return false;
        }

        if (generic.Identifier.Text != "WithContext")
        {
            return false;
        }

        if (generic.TypeArgumentList.Arguments.Count != 1)
        {
            return false;
        }

        if (generic.TypeArgumentList.Arguments[0] is not IdentifierNameSyntax ins)
        {
            return false;
        }

        return true;
    }

    private static JsonTypeModel TransformSyntaxNode(GeneratorSyntaxContext context)
    {
        var node = (InvocationExpressionSyntax)context.Node;
        var access = (MemberAccessExpressionSyntax)node.Expression;
        var generic = (GenericNameSyntax)access.Name;

        var identifier = (IdentifierNameSyntax)generic.TypeArgumentList.Arguments[0];

        var typeInfo = context.SemanticModel.GetTypeInfo(identifier);

        if (typeInfo.Type is not INamedTypeSymbol type)
        {
            // diagnostic? there should ideally be a separate analyzer catching all of these
            return default;
        }

        var jsonSerializerContext = context.SemanticModel.Compilation.GetTypeByMetadataName
        (
            "System.Text.Json.Serialization.JsonSerializerContext"
        );

        if (type.BaseType?.Equals(jsonSerializerContext, SymbolEqualityComparer.Default) == true)
        {
            // diagnostic
            return default;
        }

        var converterInitializations = CreateConverterInitializations(context, type);

        if (converterInitializations.Length <= 0)
        {
            return default;
        }

        var contextNamespace = GetContextDeclarationNamespace(context, type);

        return new()
        {
            ConverterInitializations = converterInitializations,
            Namespace = contextNamespace,
            Type = type.Name
        };
    }

    private static void Execute(SourceProductionContext context, JsonTypeModel model)
    {
#pragma warning disable SA1118 // Parameter should not span multiple lines
        context.AddSource
        (
            $"{model.Type}.AdditionalConverters.g.cs",
            $$"""
            // <auto-generated/>
            #pragma warning disable CS0618
            
            using System.Collections.Generic;
            using System.Text.Json;
            using System.Text.Json.Serialization;

            using Remora.Rest.Json.Configuration;
            using Remora.Rest.Json.Converters;
            {{model.Namespace}}
            partial class {{model.Type}} : IAdditionalConverterProvider
            {
                IReadOnlyList<JsonConverter> IAdditionalConverterProvider.AdditionalConverters { get; } = new JsonConverter[]
                {
                    {{string.Join(",\n        ", model.ConverterInitializations)}}
                };
            }
            """
        );
#pragma warning restore SA1118 // Parameter should not span multiple lines
    }

    private static string GetContextDeclarationNamespace
    (
        GeneratorSyntaxContext context,
        INamedTypeSymbol typeSymbol
    )
    {
        var contextNamespace = typeSymbol.ContainingNamespace ?? context.SemanticModel.Compilation.GlobalNamespace;
        var contextNamespaceString = contextNamespace.IsGlobalNamespace
            ? string.Empty
            : $"\nnamespace {contextNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty)};\n";

        return contextNamespaceString;
    }

    private static ImmutableArray<string> CreateConverterInitializations
    (
        GeneratorSyntaxContext context,
        INamedTypeSymbol typeSymbol
    )
    {
        var converterInitializations = new List<string>();

        var roots = typeSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.Name == "JsonSerializableAttribute")
            .Select(a => (ITypeSymbol)a.ConstructorArguments[0].Value!)
            .Where(x => x is not null)
            .ToArray();

        HashSet<ITypeSymbol> referencedTypes = new(SymbolEqualityComparer.Default);
        foreach (var root in roots)
        {
            ExpandReferencedTypes(root, referencedTypes);
        }

        List<INamedTypeSymbol> optionalTypes = new();
        INamedTypeSymbol? optionalBaseSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName("Remora.Rest.Core.Optional`1");
        foreach (var referencedType in referencedTypes.OfType<INamedTypeSymbol>())
        {
            // some simple heuristics first
            if (!referencedType.IsValueType)
            {
                continue;
            }

            if (!referencedType.IsGenericType)
            {
                continue;
            }

            if (referencedType.Name is not "Optional")
            {
                continue;
            }

            if (!referencedType.ConstructedFrom.Equals(optionalBaseSymbol, SymbolEqualityComparer.Default))
            {
                // definitely not our optional
                continue;
            }

            optionalTypes.Add(referencedType);
        }

        converterInitializations.AddRange
        (
            optionalTypes.Select
                (o => $"new OptionalConverter<{o.TypeArguments.Single().ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>()")
        );

        return converterInitializations.ToImmutableArray();
    }

    private static void ExpandReferencedTypes(ITypeSymbol symbol, HashSet<ITypeSymbol> foundTypes)
    {
        // If it has already been seen, no need to check it again.
        if (!foundTypes.Add(symbol))
        {
            return;
        }

        if (symbol.BaseType is { } @base)
        {
            ExpandReferencedTypes(@base, foundTypes);
        }

        foreach (var implementedInterface in symbol.Interfaces)
        {
            ExpandReferencedTypes(implementedInterface, foundTypes);
        }

        foreach (var member in symbol.GetMembers())
        {
            // We only care about public properties for now
            if (member.DeclaredAccessibility == Accessibility.Public &&
                member is IPropertySymbol property)
            {
                ExpandReferencedTypes(property.Type, foundTypes);
            }
        }
    }
}
