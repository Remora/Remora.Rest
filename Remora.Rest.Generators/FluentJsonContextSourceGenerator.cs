//
//  SPDX-FileName: FluentJsonContextSourceGenerator.cs
//  SPDX-FileCopyrightText: Copyright (c) Jarl Gullberg
//  SPDX-License-Identifier: LGPL-3.0-or-later
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Remora.Rest.Generators.Data;
using Remora.Rest.Generators.Runners;

namespace Remora.Rest.Generators;

/// <summary>
/// Generates System.Text.Json-based type info contexts for use in AOT scenarios.
/// </summary>
[Generator]
public class FluentJsonContextSourceGenerator : ISourceGenerator
{
    /// <inheritdoc/>
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ContextCreationCallSyntaxReceiver());
    }

    /// <inheritdoc/>
    public void Execute(GeneratorExecutionContext context)
    {
        // set up System.Text.Json generators
        var generatorAssembly = AppDomain.CurrentDomain
            .GetAssemblies()
            .First(a => a.GetName().Name is "System.Text.Json.SourceGeneration");

        var jsonGeneratorType = generatorAssembly.ExportedTypes.First(t => t.Name is "JsonSourceGenerator");

        var libraryImportGenerator = ((IIncrementalGenerator)Activator.CreateInstance(jsonGeneratorType))
            .AsSourceGenerator();

        var generators = new[] { libraryImportGenerator };

        var syntaxReceiver = (ContextCreationCallSyntaxReceiver)context.SyntaxReceiver!;
        foreach (var contextConfiguration in syntaxReceiver.Contexts)
        {
            var converterInitializations = CreateConverterInitializations(context, contextConfiguration);
            var serializationAttributes = CreateSerializationAttributes(context, contextConfiguration);
            var contextNamespace = GetContextDeclarationNamespace(context, contextConfiguration);

            var syntaxTree = SyntaxFactory.ParseSyntaxTree
            (
                $$"""
                  // <auto-generated/>
                  #pragma warning disable CS0618

                  using System;
                  using System.Runtime.CompilerServices;
                  using System.Text.Json;
                  using System.Text.Json.Serialization;
                  using Remora.Rest.Json.Contexts;
                  using Remora.Rest.Json.Converters;
                  {{contextNamespace}}
                  public partial class {{contextConfiguration.Name}} : AbstractGeneratedSerializerContext<{{contextConfiguration.Name}}>
                  {
                      static {{contextConfiguration.Name}}()
                      {
                          GeneratedContextFactory = o => new InternalGeneratedContext(o);
                          ContextFactory = o => new {{contextConfiguration.Name}}(o);
                      }

                      public {{contextConfiguration.Name}}(JsonSerializerOptions options)
                          : base
                          (
                              options,
                              new JsonConverter[]
                              {
                                  {{string.Join(",\n                ", converterInitializations)}}
                              }
                          )
                      {
                      }

                      {{string.Join("\n    ", serializationAttributes)}}
                      protected partial class InternalGeneratedContext : JsonSerializerContext
                      {
                      }

                      // It can be tricky to get a static constructor to run in an AOT scenario, especially when dealing
                      // with indirect access. Here, we set up an initializer that is guaranteed to run no matter what.
                      internal static class __{{contextConfiguration.Name}}Initializer
                      {
                          [ModuleInitializer]
                          internal static void Initialize()
                          {
                              RuntimeHelpers.RunClassConstructor(typeof({{contextConfiguration.Name}}).TypeHandle);
                          }
                      }
                  }
                  """,
                encoding: Encoding.UTF8
            );

            var hintName = $"{contextConfiguration.Name}.g.cs";
            context.AddSource(hintName, syntaxTree.GetText());

            // generate JSON glue
            GeneratorRunner.Run
            (
                context,
                hintName,
                generators,
                context.Compilation.SyntaxTrees.Concat(new[] { syntaxTree }).ToArray()
            );
        }
    }

    private static string GetContextDeclarationNamespace
    (
        GeneratorExecutionContext context,
        ContextConfiguration contextConfiguration
    )
    {
        var contextSemanticModel = context.Compilation.GetSemanticModel(contextConfiguration.Call.SyntaxTree);
        var contextNamespace = contextSemanticModel.GetEnclosingSymbol
                                   (
                                       contextConfiguration.Call.SpanStart
                                   )
                                   ?.ContainingNamespace
                               ?? context.Compilation.GlobalNamespace;

        var contextNamespaceString = contextNamespace.IsGlobalNamespace
            ? string.Empty
            : $"\nnamespace {contextNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty)};\n";

        return contextNamespaceString;
    }

    private static IReadOnlyList<string> CreateSerializationAttributes
    (
        GeneratorExecutionContext context,
        ContextConfiguration contextConfiguration
    )
    {
        var fullyQualifiedNames = contextConfiguration.DataObjects
            .Select
            (
                o => new KeyValuePair<string, string>
                (
                    GetFullyQualifiedName(o.Key, context),
                    GetFullyQualifiedName(o.Value, context)
                )
            )
            .ToArray();

        var serializationAttributes = fullyQualifiedNames
            .SelectMany(GetSerializationAttributes)
            .Distinct()
            .ToArray();

        return serializationAttributes;

        IEnumerable<string> GetSerializationAttributes(KeyValuePair<string, string> o)
        {
            yield return $"[JsonSerializable(typeof({o.Key}))]";
            yield return $"[JsonSerializable(typeof({o.Value}))]";
        }
    }

    private static IReadOnlyList<string> CreateConverterInitializations
    (
        GeneratorExecutionContext context,
        ContextConfiguration contextConfiguration
    )
    {
        if (contextConfiguration.DataObjects.Count <= 0)
        {
            return Array.Empty<string>();
        }

        var converterInitializations = new List<string>();
        var fullyQualifiedNames = contextConfiguration.DataObjects
            .Select
            (
                o => new KeyValuePair<string, string>
                    (GetFullyQualifiedName(o.Key, context), GetFullyQualifiedName(o.Value, context))
            )
            .ToArray();

        converterInitializations.AddRange
        (
            fullyQualifiedNames.Select(o => $"new InterfaceConverter<{o.Key}, {o.Value}>()")
        );

        var type = contextConfiguration.DataObjects.First().Key;
        var typeSemanticContext = context.Compilation.GetSemanticModel(type.SyntaxTree);
        var namespacesAndTypes = typeSemanticContext.LookupNamespacesAndTypes(type.SpanStart);
        var optionalType = namespacesAndTypes
            .Where
            (
                s => s is INamedTypeSymbol
                {
                    ContainingNamespace:
                    { Name: "Core", ContainingNamespace: { Name: "Rest", ContainingNamespace.Name: "Remora" } }
                }
            )
            .Cast<INamedTypeSymbol>()
            .SingleOrDefault(t => t.Name is "Optional");

        if (optionalType is null)
        {
            // type does not use any optionals
            return converterInitializations;
        }

        if (typeSemanticContext.GetSymbolInfo(type).Symbol is not ITypeSymbol symbol)
        {
            return converterInitializations;
        }

        var optionalTypes = symbol.GetMembers()
            .Where(m => m.CanBeReferencedByName && m is IPropertySymbol or IFieldSymbol)
            .Select
            (
                m => m switch
                {
                    IPropertySymbol propertySymbol => propertySymbol.Type,
                    IFieldSymbol fieldSymbol => fieldSymbol.Type,
                    _ => throw new InvalidOperationException()
                }
            )
            .Where(t => t is INamedTypeSymbol)
            .Cast<INamedTypeSymbol>()
            .Where(t => t.ConstructedFrom.Equals(optionalType, SymbolEqualityComparer.Default));

        converterInitializations.AddRange
        (
            optionalTypes.Select
                (o => $"new OptionalConverter<{GetFullyQualifiedSymbolName(o.TypeArguments.Single(), context)}>()")
        );

        return converterInitializations;
    }

    private static string GetFullyQualifiedName(TypeSyntax type, GeneratorExecutionContext context)
    {
        var semanticModel = context.Compilation.GetSemanticModel(type.SyntaxTree);

        var typeInfo = ModelExtensions.GetTypeInfo(semanticModel, type);
        return GetFullyQualifiedSymbolName(typeInfo.Type ?? throw new InvalidOperationException(), context);
    }

    private static string GetFullyQualifiedSymbolName(ITypeSymbol type, GeneratorExecutionContext context)
    {
        var keywordName = type.SpecialType switch
        {
            SpecialType.System_Boolean => "bool",
            SpecialType.System_Byte => "byte",
            SpecialType.System_Char => "char",
            SpecialType.System_Decimal => "decimal",
            SpecialType.System_Double => "double",
            SpecialType.System_Int16 => "short",
            SpecialType.System_Int32 => "int",
            SpecialType.System_Int64 => "long",
            SpecialType.System_Object => "object",
            SpecialType.System_SByte => "sbyte",
            SpecialType.System_String => "string",
            SpecialType.System_UInt16 => "ushort",
            SpecialType.System_UInt32 => "uint",
            SpecialType.System_UInt64 => "ulong",
            _ => null
        };

        if (keywordName is not null)
        {
            return keywordName;
        }

        var typeNamespace = type.ContainingNamespace
                            ?? context.Compilation.GlobalNamespace;

        var namespaceString = typeNamespace.IsGlobalNamespace
            ? "global::"
            : $"{typeNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.";

        return $"{namespaceString}{type.Name}";
    }
}
